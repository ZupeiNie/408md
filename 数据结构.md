# 数据结构

## 第一章 绪论

1.时间复杂度，空间复杂度

考点：计算时间复杂度（一般设置变量a为计算次数，经过循环计算出a，得到时间复杂度）

## 第二章 线性表

1.顺序表：逻辑顺序=物理顺序，支持动静态分配，支持随机访问，插入删除查找O(n)

2.链表：各种链表[单(头，next)、双(头，prior，next)、循环(头，prior，next，尾)]，头指针（指向链表的第一个节点)，头节点，头(尾)插法（拓展，交换数据域部分），静态链表（借用数组，next==-1）

考点：删除链表结点指针如何改动（画图模拟），设置头尾指针（操作在表头表尾，不设头设尾），判断空链表条件，顺序表与链表的比较（读取方式，逻辑物理结构，增删改查，空间分配，如何选择）

## 第三章 栈、队列和数组

1.栈：LIFO，$\frac{1}{(n+1)}C^n_{2n}$，顺序栈，共享栈（上溢），链栈

考点：栈容量，出栈序列，递归可用栈或循环，判空，判满

2.队列：FIFO，顺序队列（假溢出），循环队列（判空判满，增加size数据、增加tag，tag=0删->front=rear->空，tag=插front=rear->满），队列链表（有头有尾），双端队列

考点：出队序列，入队序列，判空，判满，双端分析出入队序列

3.栈和队列的应用：栈->中后缀表达式和递归，队列->树的层次遍历、主机和外部设备速度不匹配问题和资源竞争问题

考点：中缀表达式中操作符和操作数如何出入栈，如何转化到后缀

4.数组：对称矩阵，[右]上([左]下)三角，三对角，行(列)优先，稀疏矩阵->三元组(i,j,v)[数组或十字链表法或邻接表法]

考点：元素下标或存储地址

## 第四章 串

KMP算法，next[i]表示当子串第i个字符匹配失败时，则跳到子串的next[i]的位置继续匹配

考点：KMP算法，i，j的取值

## 第五章 树和二叉树

1.树，孩子个数为度，结点数=所有结点度数之和+1；二叉树[i,2i,2i+1,$\lfloor i/2 \rfloor$]，完全二叉树，n~0~=n~2~+1，顺序存储（0，填充为最小的完全二叉树->为满足i性质），链式存储（n+1个空链域）

考点：计算树or二叉树某种节点个数（结合性质），计算完全二叉树最多(少)有几个结点、叶结点个数、存储空间

2.二叉树遍历，层次，先序(根左右)、中序(左根右)、后序(左右根)，确定一课二叉树(中+先(后))；线索二叉树：构建（0孩子，1前驱后继）

考点：根据给的某序遍历求某序遍历序列，线索二叉树的线索指向、判前驱后继

3.树和森林：双亲表示法（0，-1）、孩子表示法、孩子兄弟表示法（二叉树表示法），树森林转化（画横线，去线；转二叉树补右结点），[树-森林-二叉树]-[先根-先序-先序]-[后根-中序-中序]

考点：树森林转化前后结点关系，转化前后结点度等等的变化，森林有几棵树，某根序列推某根序列

4.树与二叉树的应用：哈夫曼树(每次取最小的两个数组成兄弟)，哈夫曼编码，前缀；并查集

考点：构建哈夫曼树，计算WPL带权路径长度，判是否同一棵哈夫曼树，判前缀编码

## 第六章 图

1.连通图，强连通图，度，入度，出度，简单路径，简单回路

考点：非连通图最多几条边(n-1个顶点构成完全图)，有向强连通图最少边(至少n条边构成环路)，度顶点数计算

2.邻接矩阵法(稠密)，邻接表法(稀疏)，十字链表(有向，稀疏)，邻接多重表(无向)

3.图遍历，广度优先(队列，单源最短路径问题)，深度优先(实现逆拓扑排序)，图遍历可判断连通性

考点：实现广度优先遍历和深度优先遍历，不同结构下的时间复杂度

4.最小生成树（Prim算法，点，边稠密；Kruskal算法，边，边稀疏顶点多），最短路径（Dijkstra算法，单源最短路径；Floyd算法，几乎不考），有向无环图(DGA)描述表达式，拓扑序列（取点，该点无前驱，取后消去该点出发的边），AOV网，关键路径

考点：生成最小生成树选的点或边，模拟实现Dijkstra算法，求解关键路径，分析拓扑序列，活动最早开始和最晚开始时间，模拟有向无环图描述表达式

## 第七章 查找

| <span style="display:inline-block;width:100px">算法</span> | 知识点                                                       |
| :--------------------------------------------------------- | ------------------------------------------------------------ |
| 顺序查找                                                   | 从一端查找到另一端，有则查找成功无则查找失败，引入哨兵置[0]，从后向前查找，减少判断语句；ASL较大，效率低，对数据存储无要求 |
| 折半查找                                                   | 取中间（向下取整）判断，小则向前，大则向后；只适用有序，需要随机存取 |
| 分块查找                                                   | 先顺序or折半查找索引表找块，后块内顺序查找；块内无序，块间有序 |
| 二叉排序树                                                 | 中序有序，判断顺序根->左子树->右子树，插入(比根小去左大去右且为查找路径最后一个结点的孩子)，构造，删除(右空左补，左空右补，都不空补右子树中序第一个结点) |
| 平衡二叉树                                                 | 平衡因子为$\pm{1}$，0，插入(LL,RR,LR,RL)，删除，查找，最少结点数(所有非叶结点的平衡因子都为1)n~h~=n~h-1~+n~h-2~+1，n~0~=0，n~1~=1，n~2~=2 |
| 红黑树                                                     | ==p289==                                                     |
| B树                                                        | 最大孩子个数m为阶，高h的m阶B树的关键字根至少1个，至多m-1个，非叶结点至少有$\lceil m/2 \rceil$-1个，至多m-1个，n个关键字的结点有n+1个孩子，叶结点不带信息视作外部结点or折半查找的失败结点；插入(取中拆分)，删除(可直接删除、兄弟够借，用父子换位法、兄弟不够借，临近兄弟加小于它且在双亲的元素组成新的孩子结点) |
| B^+^树                                                     | 高h的m阶B^+^树的关键字根至少2个，至多m个，非叶结点至少有$\lceil m/2 \rceil$个，至多m个，n个关键字的结点有n个孩子，叶结点包含信息(包含所有关键字，相邻叶结点按顺序链接)，非叶结点起索引作用(包含孩子结点中最大关键字，和指向它的指针)，支持从最小关键字开始的顺序查找和从根开始的多路查找，每次查找都是从根到叶的路径 |
| 散列表                                                     | 构造：直接定址法($H(key)=key$或$H(key)=a*key+b$)，除留余数法($H(key)=key\%p$)，数字分析法，平方取中法；冲突：开放定址法[线性探测法、平方探测法，m为4*k+3的素数、双散列法、伪随机序列法]，拉链法 |

| 算法        | 考点                                                         |
| ----------- | ------------------------------------------------------------ |
| 顺序查找    | 顺序查找判定树，计算查找成功失败的比较次数                   |
| 折半查找    | 折半查找判定树，比较次数，折半关键字比较序列(全大全小)       |
| 分块查找    |                                                              |
| 二叉排序树  | 删除并插入同一结点前后不一定一致，查找路径(全大全小)         |
| 平衡二叉树  | 模拟构建插入删除，查找比较次数，结点个数                     |
| 红黑树      |                                                              |
| B树和B^+^树 | 高h的m阶B树至少有几个关键字，B树的插入删除操作               |
| 散列表      | 模拟线性探测法，计算查找成功和查找失败ASL，装填因子$\alpha=\frac{表中记录数n}{散列表长度m}$ |

## 第八章 排序

| <span style="display:inline-block;width:100px">算法</span>         | 知识点                                                       |
| ------------ | ------------------------------------------------------------ |
| 插入排序     | 后向前找位置，边找边后挪，找到插入；适用于线性表             |
| 折半插入排序 | 折半查找到位置，插入                                         |
| 希尔排序     | 取d~1~为步长，表中距离为d~1~的分在一组，组内直接插入排序，之后取d~2~直到d~t~=1；仅适用顺序存储线性表 |
| 冒泡排序     | 从前向后或从后向前两两比较相邻元素，逆序则交换，最多n-1趟    |
| 快速排序     | 分治法，取首元素为基准，i为low，j为high，i从前向后遇到大于基准的元素则和j位置元素交换，之后j从后向前遇到小于基准的元素与i位置元素交换，再i再j直到i==j，分成了两个序列，之后两序列分别重复上述操作，递归，内部排序算法中平均性能最优 |
| 简单选择排序 | 从前向后找到比关键词小的元素，交换                           |
| 堆排序       | 大根堆，小根堆，构造and插入(新结点放在堆的末端，从完全二叉树的最后一个分支结点开始判断，依次向上到根然后再向下)，删除(删除根后用堆的末端元素来补，然后从根向下调整)，比较先兄弟再双亲 |
| 归并排序     | 将n个有序表合并成一个有序表，x路归并排序表示xx归并(例如两两归并)，针对大文件 |
| 基数排序     | 不基于比较，通常为链式基数排序，个位十位百位                 |
| 归并排序法   | 外部排序，多路平衡归并，败者树(分支结点记录孩子中的败者，根为最后的结果) |
| 置换选择排序 | 工作区容量w，文件f输入w个关键字到工作区，选出最小值标记为MINIMAX并输出，f继续输入，找出工作区中大于MINIMAX的最小值，若都小于MINIMAX则选择这w个中的最小值，更新MINIMAX并输出，持续上述操作至f空 |

| 算法         | 考点                                                         |
| ------------ | :----------------------------------------------------------- |
| 插入排序     |                                                              |
| 折半插入排序 |                                                              |
| 希尔排序     | 求步长，求排序几轮                                           |
| 冒泡排序     | 一轮确定一个元素的位置                                       |
| 快速排序     | 模拟快排x轮结果，一轮确定一个元素的位置                      |
| 简单选择排序 | 一轮确定一个元素的位置                                       |
| 堆排序       | 模拟建堆，比较次数，一轮确定一个元素的位置                   |
| 归并排序     |                                                              |
| 基数排序     | 模拟基数排序                                                 |
| 归并排序法   |                                                              |
| 置换选择排序 | 模拟置换选择排序                                             |
| 最佳归并树   | 虚段，度为0的结点为n~0~，度为k的结点为n~k~，k叉树，u=(n~0~-1)%(k-1)，若u不为0，补充k-u-1个虚段 |

| 算法         | 最好        | 平均        | 最坏        | 空间复杂度 | 是否稳定 |
| ------------ | ----------- | ----------- | ----------- | ---------- | -------- |
| 直接插入排序 | O(n)        | O(n^2^)     | O(n^2^)     | O(1)       | 是       |
| 冒泡排序     | O(n)        | O(n^2^)     | O(n^2^)     | O(1)       | 是       |
| 简单选择排序 | O(n^2^)     | O(n^2^)     | O(n^2^)     | O(1)       | 否       |
| 希尔排序     |             |             |             | O(1)       | 否       |
| 快速排序     | O(nlog~2~n) | O(nlog~2~n) | O(n^2^)     | O(log~2~n) | 否       |
| 堆排序       | O(nlog~2~n) | O(nlog~2~n) | O(nlog~2~n) | O(1)       | 否       |
| 2路归并排序  | O(nlog~2~n) | O(nlog~2~n) | O(nlog~2~n) | O(n)       | 是       |
| 基数排序     | O(d(n+r))   | O(d(n+r))   | O(d(n+r))   | O(r)       | 是       |

